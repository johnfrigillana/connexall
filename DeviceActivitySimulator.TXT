uses SysUtils;

const

    codes = [1,  //   1 = user saw message and terminated ("done")
             2,  //   2 = user saw message and chose to call audio dn
             3,  //   3 = user saw message and chose to escalate it
             4,  //   4 = user responded to notification but has not chosen an option yet ("user aware")
             5,  //   5 = user chose a custom menu option
             6,  //  6 = user saw message and chose to cancel it
             1000]; // 1000 = user did not respond at all

    prob = [14.3,  //  Probability that user saw message and terminated ("done")
            14.3,  //  Probability that user saw message and chose to call audio dn
            14.3,  //  Probability that user saw message and chose to escalate it
            14.3,  //  Probability that user responded to notification but has not chosen an option yet ("user aware")
            14.3,  //  Probability that user chose a custom menu option
            14.3,   //  Probability that user saw message and chose to cancel it
            14.2]; //   Probability that did not respond at all
    sizeOfList = 7;

//test line
var
    devId,
    devType,
    devLabel;
    cumulativeProb,
    devAction;

    //add for two lists
    EventListActive;
    CPListActive;


// input current Callpoint Status, return Device Activity base on algorithm

// things to consider:
// 1. If CP Level = 3, you cannot escalate it anymore
// 2. You cannot cancel Code Blue without ACK ( or any alarm with Priority 0~ 10)
// 3. since we have this function run every second, or 1~5 seconds, we
//    need a large probably set as "Do Nothing" so we can make a delay


// For now, Probailities set as:
// ( the following prob is actually pretty high, the lowest priority (0.2% ack) will be more
//   likely to acked in 2 minutes), because the probabilities are applied each second

// 1. Priority 0 ~ 10: 50% +- 10% ACK;
// 2. Priority 11 ~ 20: 40% +- 10% ACK;
// 3. Priority 21 ~ 30: 30% +- 10% ACK;
// 4. Priority 31 ~ 40: 20% +- 10% ACK;
// 5. Priority 41 ~ 50: 10% +- 5% ACK;
// 6. Priority 51 ~ 60: 5% +- 3% ACK;
// 7. Priority 61 ~ 70: 2% +- 1% ACK;
// 8. Priority 71 ~ 80: 1% +- 0.5% ACK;
// 9. Priority 81 ~ 999: 0.5% +- 0.3% ACK

procedure get_DevActivity;
begin



end;

// return Priority number based on:
// 1 --> Priority 0 ~ 10
// 2 --> Priority 11 ~ 20
// 3 --> Priority 21 ~ 30
// 4 --> Priority 31 ~ 40
// 5 --> Priority 41 ~ 50         
// 6 --> Priority 51 ~ 60
// 7 --> Priority 61 ~ 70
// 8 --> Priority 71 ~ 80
// 9 --> Priority 81 ~ 999

function get_priority(Priority:Integer):Integer;
begin
    if (Priority > 80) then
        begin
            Result := 9;
            //Exit(9);
        end;

    else if (Priority mod 10) = 0 then
        begin
        //the number is 0, 10, 20, 30...
            if (Priority = 0) then
                begin
                    Result := 1;
                    //Exit(1);
                end
            else 
                begin
                    //Exit(Priority div 10);
                    Result := Priority div 10;
                end;
        end
    else  
        begin
            if (Priority < 10) then
                begin
                    //
                    //writeln('Hello, worrld!');
                    Result := 1;
                    //Exit(1)
                end
            else
                begin
                    //Exit((Priority div 10) + 1);
                    Result := (Priority div 10) + 1;
                end;
        end;
end;






procedure addProbability;                                 
begin
    cumProbTemp := 0.0;
    arraySize := sizeOfList - 1;
    for loopCount := 0 to arraySize do
    begin
       cumProbTemp := cumProbTemp + prob[loopCount];
       cumulativeProb[loopCount] := cumProbTemp;
      // Command.SendToLog(FloatToStr(cumulativeProb[loopCount]));
    end;
end;

function countIf(number : Integer): Integer;
begin
    tempAns := 0;
    arraySize := sizeOfList - 1;
    for loopCount := 0 to arraySize do
    begin
       if cumulativeProb[loopCount] <= number then
       begin
           tempAns := tempAns + 1
       end;
    end;
    Result:= tempAns;
end;

function HandleNewPacket (RxData);
begin
  //Implement code to parse/process incoming data from host system.

  Command.SendToLog ('Got raw data: ' + RxData);
end;



procedure InitializeScript;

begin
  //Implement any required initialization code here that should be executed when the script is first run.
  //Example: preset variables, start the timer, etc.
   cumulativeProb := [0.0,0.0,0.0,0.0,0.0,0.0,0.0];
   addProbability;
   Command.SendToLog('Hello');

   CPListActive := TStringList.Create;
<<<<<<< HEAD
   EventListActive := TString.Create;
=======
   EventListActive := TStringList.Create;
>>>>>>> 1287a94fb05386fd7b0d8bd30201ce35840cf845




end;


procedure FinalizeScript;
begin
  //Implement any required finalization code here that should be executed when the script stops running.
  //Example: clean memory, free objects, etc.
end;


function HandleDevNotify (ExtractedNativeDevID, EvtType, EventID, DevInfo, CpInfo);

begin



//Begin Script
    Command.SendToLog (Format ('Received callpoint notify event. EvtType:%s / EventID:%s / DevInfo:%s / CpInfo:%s',
        [EvtType, EventID, DevInfo, CpInfo]));

    devId := Command.GetRxDataParamInteger ('[DEV_ID=', DevInfo, 0);
    devType := Command.GetRxDataParamInteger ('[TYPE=', DevInfo, 0);
    devLabel := Command.GetRxDataParamString ('[LABEL=', DevInfo, '<DEV LABEL NOT FOUND>');

    if EvtType = 'ACTIVE' then

        begin

            // my idea is different here.  so I will make this commanded out.
            Command.SendToLog('Received Active Event type');

            // since you made a probably of NOT trigger the alarm, so this made a
            // conflict with my code below .

            // ALSO note there is a bug in my code here:
            // If callpoint is a re-try or escalation, is will add duplicate callpoints
            // in the list, so leave this here for now, I need a if statement ...

            //CPListActive.Append(CpInfo);
            //EventListActive.Append(EventID);


            randomNumber := Command.GetRandomInteger(0,101);
            temporary := countIf(randomNumber) + 1;
            devAction := codes[temporary - 1];
            if devAction <> 1000 then
                begin
                Command.SendDevNotifyStatusToServer (EventID,
                                           devId,
                                           devType,
                                           devLabel,
                                           devAction,
                                           '');
                end;
        end;

    else if EvtType = 'CANCEL' then
        begin
            Command.SendToLog('Received Cancel Event type');

            // command out for now due to potential bug
            //Index := EventListActive.Indexof(EventID);
            //CPListActive.Delete(Index);
        end;





  //Note: HandleDevNotify is a function, so a True/False "return value" should be specified to signify the success/failure to process the notification.
    //Result := False; //the client will send a device status message to the server of "Host Offline" (i.e. status code = -3)
    Result := True; //the client will send a device status message to the server of "Host Accepted Message" (i.e. status code = 10)

  //Option to enable/disable the HandleDevNotify messages for optional flow control (enabled by default)
    {Parameter list:
      - enable/disable messages (True/False)}
    //Command.ReadyForDevNotifyEvents (False);
    Command.ReadyForDevNotifyEvents (True);

  //Option to enable/disable the processing of HandleDevNotify messages (and Timer) events even when the host interface is offline (disabled by default)
    {Parameter list:
      - enable/disable script operation when host offline (True/False)}
   //Command.RunWhileHostOffline (True);
    Command.RunWhileHostOffline (False);


end;


procedure HandleRtlsTagLocationChange (TagID: integer; TagLabel: string; TagNativeID: string;
  RTLSID: integer; NewLocID, NewLocLabel, PrevLocID, PrevLocLabel: string; PrevLocEntryTime: TDateTime);
begin
  // Implement code that can process RTLS tag location change events
end;


procedure TimerEvent;
begin
  //Implement code that must be called on a regular basis (for state machines, etc.)
  //Note: refer to Command.EnableTimer, Command.DisableTimer and Command.RunWhileHostOffline procedures to enable/disable timer events.
end;




